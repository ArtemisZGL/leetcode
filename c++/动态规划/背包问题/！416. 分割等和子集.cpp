/*
动态规划的0-1背包问题，可以看成是将nums加起来，然后背包容量是sum/2，如果能放满就是能分开。

0-1背包:
有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。
状态定义：
（j从0到总体积W， 也就是每个物品的状态和物品的第几个以及当前容量有关）
定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。
设第 i 件物品体积为 w，价值为 v
状态转移方程：
（还要判断能不能放下）
根据第 i 件物品是否添加到背包中，可以分两种情况讨论：
1.第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，
dp[i][j] = dp[i-1][j]。
2.第 i 件物品添加到背包中，
dp[i][j] = dp[i-1][j-w] + v。
最后取这两种情况的最大值

线性空间优化：
观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，
因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。

状态定义：
dp(j)表示的是在当前第几个物品下，容量为j的背包最大价值
状态转移：
因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，以防将 dp[i-1][j-w] 覆盖。
也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，
（因为我们现在只用了一维数组来存，而求dp[i][j]时是要用到dp[i-1][j-w]的，也就是dp(j)要用到之前的dp(j-w)，
而不是这一轮的dp(j-w)，所以在对容量进行遍历的时候要从后面开始倒序进行遍历）




*/

class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
        }
        //不能分成两半，直接返回false
        if(sum % 2 != 0)
            return false;
        
        int W = sum / 2;
        //这里没有价值的概念，只有能不能放慢，D表示能不能前i个物品将容量j放满
        vector<bool> D(W + 1, false);
        //初始化
        D[0] = true;
        for(int i = 0; i < nums.size(); i++)
        {
            //要从后面开始遍历，直到比当前物品容积小为止
            for(int j = W; j >= nums[i]; j--)
            {
                //之前已经放满了D[j] 或者是 加上当前物品能够放满，也就是D[j - nums[i]]之前可以放满
                D[j] = D[j] || D[j - nums[i]];
            }
        }
        //最后看W能不能放满
        return D[W];
    }
};
