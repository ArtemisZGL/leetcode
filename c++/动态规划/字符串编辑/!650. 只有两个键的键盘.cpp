/*
动态规划：

设立状态: d[i]表示i个需要多少次操作

状态转移方程：d[i]可以由其它的复制过来，最少就是一直粘贴一个，最多就是一半然后粘贴一次
             但是粘贴的要求是不能超过要求的个数，所以j从1遍历到i/2, 如果刚好能够整除的话才可以用来粘贴
             然后取最小的

初始状态：d[0] = 0, d[1] = 0 因为本来就已经有一个了
*/

/*
最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：

Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
Paste (粘贴) : 你可以粘贴你上一次复制的字符。
给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。

示例 1:

输入: 3
输出: 3
解释:
最初, 我们只有一个字符 'A'。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 'AA'。
第 3 步, 我们使用 Paste 操作来获得 'AAA'。
*/

class Solution {
public:
    int minSteps(int n) {
        if(n <= 1)
            return 0;
        
        int D[n+1];
        D[1] = 0;
        D[0] = 0;
       
        for(int i = 2; i <= n; i++)
        {
            //初始化，最多的操作就是i次
            D[i] = i;
            
            for(int j = 1; j <= i / 2; j++)
            {
                //确保整除来保证粘贴不会让操作数超过i
                if(i % j == 0)
                {
                    //这里注意是D[j] + i/j 含义是复制粘贴了i/j次
                    D[i] = min(D[i], D[j] + i / j);
                }
            }
        }
        
        return D[n];
    }
};
