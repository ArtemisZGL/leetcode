/*
动态规划，二维动态规划进行压缩，搜索问题
用一维数组而不是二维数组，不仅节省了空间，在寻址的过程中也节约了一定的时间
定义状态D(j)，表示的是到达某一行中第j列所花费的数字总和，然后到达下一行的时候对每一列的值都要进行更新
状态转移方程(一行一行，按列进行转移)：Di(j) = min(Di-1(j), Di(j-1)) + grid(i,j)
初始化，只要初始化第一个，然后注意在第一行中只能通过往右走到达，第一列只能通过往下走到达
*/

/*
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
*/
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size() == 0 || grid[0].size() == 0)
            return 0;
        
        int r = grid.size();
        int c = grid[0].size();
        //先全部初始化为0 
        int d[c];
        for(int i = 0; i < c; i++)
			d[i] = 0; 
        
        for(int i = 0; i < r; i++)
        {
            for(int j = 0; j < c; j++)
            {
                //如果是第一列
                if(j == 0)
                    d[j] = d[j];
                //如果是第一行
                else if(i == 0)
                    d[j] = d[j-1];
                else
                    d[j] = min(d[j], d[j-1]);
                
                //最后加上现在这一个的开销
                d[j] += grid[i][j];
            }
        }
        
        //最后返回右下角的状态即为开销
        return d[c-1];
    }
};
