//https://segmentfault.com/a/1190000016315625
/*
二维动态规划的问题，同样可以用压缩进行优化
用一维数组而不是二维数组，不仅节省了空间，在寻址的过程中也节约了一定的时间
定义状态D(j)，表示的是到达某一行中第j列的方案数，然后到达下一行的时候对每一列的值都要进行更新
状态转移方程(一行一行，按列进行转移)：Di(j) = Di-1(j), Di(j-1)，即现在这个格子的方案等于上面的格子方案加左边格子方案
初始化，只要初始化第一个，然后注意在第一行中只能通过往右走到达，第一列只能通过往下走到达
初始化的方案数为1
*/

/*
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？



例如，上图是一个7 x 3 的网格。有多少可能的路径？

说明：m 和 n 的值均不超过 100。

示例 1:

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
*/
class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m == 0 || n == 0)
            return 1;
        
        //先全部初始化为1，因为我们后面直接跳过了第一行
        int d[n];
        for(int i = 0; i < n; i++)
           d[i] = 1;
        
        //从第一行开始
        for(int i = 1; i < m; i++)
        {
            //从第一列开始，和那个找最短路径不同，他第一列永远都只有一种方案
            for(int j = 1; j < n; j++)
            {
                //下一行的这一列就等于上一行的这一列加上下一行的前一列
                d[j] = d[j-1] + d[j];
            }
        }
        
        return d[n-1];
    }
};
