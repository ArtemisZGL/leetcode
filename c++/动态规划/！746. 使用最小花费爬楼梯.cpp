/*
先定义状态D[i]，表示到达第i个台阶花费的
状态转移方程 D[i] = min(D[i-1], D[i-2]) + cost[i-1]
初值 D[1] = cost[0], D[2] = cost[1]
*/

/*
数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

示例 1:

输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
 示例 2:

输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
*/ 
class Solution {
public:
    vector<int> D;
    int minCostClimbingStairs(vector<int>& cost) {
        if(cost.size() <= 0)
            return 0;
        if(cost.size() == 1)
            return 0;

        D = vector<int>(cost.size() + 2, -1);
        D[1] = cost[0];
        D[2] = cost[1];
        //设置最顶的那个花费为0
        cost.push_back(0);
        return getMincost(cost, cost.size());
    }
    
    int getMincost(vector<int>& cost,int n)
    {
        if(n <= 0)
            return 0;
        //第一二级台阶
        if(n <= 2)
            return D[n];
        
        int fir = D[n-1] == -1 ? getMincost(cost, n-1) : D[n-1];
        int sec = D[n-2] == -1 ? getMincost(cost, n-2) : D[n-2];
        
        int m = min(fir, sec);
        D[n] = m + cost[n - 1];
        
        return D[n];
    }
};
