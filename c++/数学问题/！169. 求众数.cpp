/*
想法1：先对数组排序，然后取中间位置的元素，再对数据扫描一趟来判断此元素是否为多数元素。时间复杂度O(nlog(n))，空间复杂度O(1)。

想法2：使用一个hash表，对数组进行一趟扫描统计每个元素出现的次数，并且在过程中纪录出现最多的数以及出现的次数，即可得到多数元素。时间复杂度O(n)，空间复杂度O(n)。
*/

/*
摩尔投票算法 时间复杂度为O(n)，空间复杂度为O(1)

算法在局部变量中定义一个序列元素(m)和一个计数器(i)，初始化的情况下计数器为0. 算法依次扫描序列中的元素，当处理元素x的时候，
如果计数器为0，那么将x赋值给m，然后将计数器(i)设置为1，如果计数器不为0，那么将序列元素m和x比较，如果相等，那么计数器加1，
如果不等，那么计数器减1。处理之后，最后存储的序列元素(m)，就是这个序列中最多的元素。

数组中可能不存在多数元素的话，最后还要再扫描一次来判断是不是多数元素

https://blog.csdn.net/qq_38735931/article/details/82386177
个人理解，计数器相当于是当前候选元素比其它所有元素多的个数，如果为0则说明在已检验的部分中他不是多数元素，
并且已检验的部分也没有比他多的（和他个数相等），然后开始下一段的检验，如果是多数元素的话，总会有一段的计数器大于0
*/

/*

给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ? n/2 ? 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2
*/ 


class Solution {
public:
    int majorityElement(vector<int>& nums) {
        if(nums.size() == 0)
            return 0;
        
        int candidate = nums[0], count = 1;
        
        for(int i = 1; i < nums.size(); i++)
        {
            if(count == 0)
            {
                candidate = nums[i];
                count = 1;
                continue;
            }
            
            if(candidate == nums[i])
                count++;
            else
                count--;
        }
        
        return candidate;
    }
};
